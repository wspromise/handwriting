<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>继承</title>
  </head>
  <body>
    <script>
      // 原型链继承（子类的构造函数的显示原型等于父类的一个实例）缺点：新实例无法向父类构造函数传参
      // function Person(name, age) {
      //   this.name = name;
      //   this.age = age;
      //   this.say = function () {
      //     console.log('say');
      //   };
      // }

      // Person.prototype.say = function () {
      //   console.log('my name is ' + this.name);
      // };

      // function Man(aaa) {
      //   this.aaa = aaa;
      // }

      // Man.prototype = new Person();
      // Man.prototype.constructor = Man;

      // let m = new Man(100);
      // console.log(m);

      // 借用构造函数继承（子类中用call或apply绑定子类实例，借用父类的构造函数实例化属性和方法）缺点：无法继承父类显示原型上的属性和方法
      // function Person(name, age) {
      //   this.name = name;
      //   this.age = age;
      //   this.say = function () {
      //     console.log('say');
      //   };
      // }

      // Person.prototype.say = function () {
      //   console.log('my name is ' + this.name);
      // };

      // function Man(name, age, aaa) {
      //   Person.call(this, name, age);
      //   this.aaa = aaa;
      // }

      // let m = new Man('Tom', 18, 100);
      // console.log(m);

      // 组合式继承（原型链继承和构造函数继承的组合，缺点：调用2遍父类构造函数消耗内存）
      // function Person(name, age) {
      //   this.name = name;
      //   this.age = age;
      //   this.say = function () {
      //     console.log('say');
      //   };
      // }

      // Person.prototype.say = function () {
      //   console.log('my name is ' + this.name);
      // };

      // function Man(name, age, aaa) {
      //   Person.call(this, name, age);
      //   this.aaa = aaa;
      // }

      // Man.prototype = new Person();
      // Man.prototype.constructor = Man;

      // let m = new Man('Tom', 18, 100);
      // console.log(m);

      // 原型式继承（封装一个容器用于返回继承父类实例的一个实例对象，缺点：无法实现复用，新实例属性都是后面添加的）
      // function Person(name, age) {
      //   this.name = name;
      //   this.age = age;
      //   this.say = function () {
      //     console.log('say');
      //   };
      // }

      // Person.prototype.say = function () {
      //   console.log('my name is ' + this.name);
      // };

      // function content(obj) {
      //   function F() {}
      //   F.prototype = obj;
      //   return new F();
      // }

      // let p = new Person('Tom', 18);
      // let con1 = content(p);
      // con1.aaa = 100;
      // let con2 = content(p);
      // console.log(con1, con2);

      // 寄生式继承 （在原型式继承基础上套个壳子，用于传递参数， 缺点：没用到原型，无法复用）
      // function Person(name, age) {
      //   this.name = name;
      //   this.age = age;
      //   this.say = function () {
      //     console.log('say');
      //   };
      // }

      // Person.prototype.say = function () {
      //   console.log('my name is ' + this.name);
      // };

      // function content(obj) {
      //   function F() {}
      //   F.prototype = obj;
      //   return new F();
      // }

      // // 给每个实例添加属性，没添加到原型上，不节省内存
      // function subObject(obj) {
      //   var sub = content(obj);
      //   sub.name = 'gar';
      //   return sub;
      // }

      // let p = new Person('Tom', 18);
      // var sup2 = subObject(p);
      // console.log(sup2);

      // 寄生组合式继承（原型链继承，构造函数继承，原型式继承的组合，比较常用）
      // function Person(name, age) {
      //   this.name = name;
      //   this.age = age;
      //   this.say = function () {
      //     console.log('say');
      //   };
      // }

      // Person.prototype.say = function () {
      //   console.log('my name is ' + this.name);
      // };

      // function content(obj) {
      //   function F() {}
      //   F.prototype = obj;
      //   return new F();
      // }

      // // con实例继承了父类原型上的属性和方法
      // let con = content(Person.prototype);

      // function Man(name, age, aaa) {
      //   Person.call(this, name, age); // 继承父类构造函数上的属性和方法
      //   this.aaa = aaa;
      // }

      // Man.prototype = con;
      // Man.prototype.constructor = Man;

      // let m = new Man('Tom', 18, 100);
      // console.log(m);

      // class继承
      class Animal {
        constructor(name, age) {
          this.name = name;
          this.age = age;
        }
        eat(food) {
          console.log('吃' + food);
        }
        running() {
          console.log('奔跑');
        }
      }

      class Cat extends Animal {
        weight = null;
        constructor(name, age, weight) {
          super(name, age);
          this.weight = weight;
        }
        sleep() {
          console.log('睡觉');
        }
      }

      let cat = new Cat('jack', 18, 6);
      console.log(cat);
    </script>
  </body>
</html>
